# Liskov Substitution Principle (LSP)

## Overview
- **Definition**: Objects of a superclass should be replaceable with objects of its subclass without affecting the correctness of the program.
- **Purpose**: Ensures well-designed inheritance hierarchies where subclasses adhere to the behavioral contracts of their superclasses, maintaining predictability and reliability.
- **Violation Consequences**: Substituting a subclass can lead to unexpected behavior or errors, making code harder to reason about and maintain.

## Naive Example: Violating LSP
- **Classes**:
  - `Shape` (Abstract): Defines an abstract `area` method.
  - `Rectangle`: Inherits `Shape`, with `width` and `height` attributes and getter/setter properties.
  - `Square`: Inherits `Rectangle`, overriding setters to enforce equal `width` and `height`.
- **Code**:
  ```python
  from abc import ABC, abstractmethod

  class Shape(ABC):
      @abstractmethod
      def area(self) -> float:
          pass

  class Rectangle(Shape):
      def __init__(self, width: float = 0.0, height: float = 0.0):
          self._width = width
          self._height = height

      @property
      def width(self) -> float:
          return self._width

      @width.setter
      def width(self, value: float):
          self._width = value

      @property
      def height(self) -> float:
          return self._height

      @height.setter
      def height(self, value: float):
          self._height = value

      def area(self) -> float:
          return self.width * self.height

  class Square(Rectangle):
      def __init__(self, side: float = 0.0):
          super().__init__(side, side)

      @Rectangle.width.setter
      def width(self, value: float):
          self._width = value
          self._height = value

      @Rectangle.height.setter
      def height(self, value: float):
          self._height = value
          self._width = value

  rect = Square()
  rect.width = 5   # Sets both width and height to 5
  rect.height = 10 # Sets both width and height to 10
  print("Expected area = 5 * 5 = 25.")  # Misleading expectation
  print("Calculated area = " + str(rect.area()))  # Output: 100
  ```
- **Problem**:
  - **LSP Violation**: Substituting a `Square` for a `Rectangle` breaks the expected behavior. A `Rectangle` allows independent `width` and `height`, but `Square` enforces equal dimensions, leading to incorrect area calculations (e.g., `10 * 10 = 100` instead of `5 * 5 = 25`).
  - **Cause**: `Square`’s overridden setters change the contract of `Rectangle`, violating the assumption that `width` and `height` can be set independently.
  - **Issues**:
    - Unexpected behavior when substituting `Square` for `Rectangle`.
    - Complex `Rectangle` class with unnecessary getters/setters to accommodate `Square`.

## Refactored Example: Adhering to LSP
- **Solution**: Remove inheritance of `Square` from `Rectangle`, making both direct subclasses of `Shape` with independent implementations.
- **Classes**:
  - `Shape` (Abstract): Defines `area` method.
  - `Rectangle`: Simple implementation with `width` and `height`.
  - `Square`: Independent implementation with a single `side` attribute.
- **Code**:
  ```python
  from abc import ABC, abstractmethod

  class Shape(ABC):
      @abstractmethod
      def area(self) -> float:
          pass

  class Rectangle(Shape):
      def __init__(self, width: float = 0.0, height: float = 0.0):
          self.width = width
          self.height = height

      def area(self) -> float:
          return self.width * self.height

  class Square(Shape):
      def __init__(self, side: float = 0.0):
          self.side = side

      def area(self) -> float:
          return self.side * self.side

  rect = Rectangle()
  rect.width = 5
  rect.height = 10
  print("Expected area = 10 * 5 = 50.")
  print("Calculated area = " + str(rect.area()))

  square = Square()
  square.side = 5
  print("Expected area = 5 * 5 = 25.")
  print("Calculated area = " + str(square.area()))
  ```
- **Demonstrating LSP**:
  ```python
  def return_area(shape: Shape) -> float:
      return shape.area()

  print(return_area(Rectangle(5, 10)))  # Output: 50
  print(return_area(Square(5)))         # Output: 25
  ```
- **Benefits**:
  - **LSP Compliance**: Both `Rectangle` and `Square` can be substituted for `Shape` without altering program correctness, as each adheres to the `area` contract independently.
  - **Simplified Design**: `Rectangle` no longer needs complex getters/setters; `Square` uses a single `side` attribute.
  - **Polymorphism**: The `return_area` function treats all `Shape` subclasses uniformly, calculating areas correctly.

## Key Points
- **LSP Violation**: Occurs when a subclass (e.g., `Square`) changes the expected behavior of a superclass (e.g., `Rectangle`), causing incorrect results when substituted.
- **Solution**: Avoid inappropriate inheritance hierarchies (e.g., `Square` inheriting from `Rectangle`) and ensure subclasses maintain the superclass’s contract.
- **Benefits of Adherence**:
  - Predictable behavior when substituting subclasses.
  - Simpler, more maintainable code with clear responsibilities.
  - Enables polymorphism without risking errors.
- **Design Insight**: A square is not a behavioral subtype of a rectangle, despite mathematical intuition, as it cannot support independent `width` and `height` changes.

## Summary
- **LSP**: Ensures subclasses can replace superclasses without breaking program correctness, maintaining reliable inheritance hierarchies.
- **Violation Example**: `Square` inheriting from `Rectangle` breaks LSP by enforcing equal dimensions, leading to incorrect area calculations.
- **Fix**: Make `Square` and `Rectangle` independent subclasses of `Shape`, each implementing `area` appropriately.
- **Outcome**: Robust, maintainable code that supports polymorphism and correct substitutions.