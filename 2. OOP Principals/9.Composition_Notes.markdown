# Composition in Object-Oriented Programming

## Overview
- **Definition**: Composition involves building complex objects by combining simpler objects (components), where each component maintains its own state and behavior.
- **Relationship**: Described as a "has-a" relationship (e.g., a car *has* an engine, *has* seats), unlike inheritance’s "is-a" relationship (e.g., a car *is* a vehicle).
- **Purpose**: Promotes modularity by assembling objects from independent components, hiding low-level details from users.

## Example: Car Composition
- **Components** (Low-Level Classes):
  - `Engine`: Has a `start()` method.
  - `Wheels`: Has a `rotate()` method.
  - `Chassis`: Has a `support()` method.
  - `Seats`: Has a `sit()` method.
- **High-Level Class**: `Car`
  - Composed of instances of `Engine`, `Wheels`, `Chassis`, and `Seats`.
  - Delegates tasks to these components in its `start()` method.
- **Code**:
  ```python
  class Engine:
      def start(self):
          print("Starting engine")

  class Wheels:
      def rotate(self):
          print("Rotate")

  class Chassis:
      def support(self):
          print("Chassis supporting the car")

  class Seats:
      def sit(self):
          print("Sitting on seats")

  class Car:
      def __init__(self):
          self._engine = Engine()
          self._wheels = Wheels()
          self._chassis = Chassis()
          self._seats = Seats()

      def start(self):
          self._engine.start()
          self._wheels.rotate()
          self._chassis.support()
          self._seats.sit()
          print("Car started.")

  car = Car()
  car.start()
  ```
- **Output**:
  ```
  Starting engine
  Rotate
  Chassis supporting the car
  Sitting on seats
  Car started.
  ```

## Key Points
- **Composition**:
  - `Car` is composed of component objects (`Engine`, `Wheels`, `Chassis`, `Seats`), each handling its own functionality.
  - Components are stored as protected attributes (e.g., `_engine`) to hide implementation details from users.
- **Delegation**: The `Car` class delegates tasks (e.g., starting the engine, rotating wheels) to its components by calling their methods.
- **Abstraction**: Users of the `Car` class only call `start()`, without needing to understand or interact with the components’ low-level operations.
- **Modularity**: Each component is a separate class, making it easier to modify or replace individual parts without affecting the `Car` class.

## Benefits
- **Encapsulation**: Hides component complexity, exposing only high-level functionality (e.g., `start()`).
- **Flexibility**: Components can be swapped or modified independently (e.g., replacing `Engine` with a different type).
- **Maintainability**: Changes to component behavior don’t impact the `Car` class, as long as the component interface remains consistent.
- **Reusability**: Components can be reused in other high-level classes (e.g., `Engine` in a truck).

## Summary
- Composition builds complex objects from simpler, independent components, using a "has-a" relationship.
- It promotes modularity, abstraction, and maintainability by delegating tasks to components, allowing users to interact with a simplified interface.