Encapsulation in Object-Oriented Programming
Overview

Definition: Encapsulation bundles data (attributes) and methods (behaviors) into a single unit (class), hiding internal implementation details and exposing only necessary functionalities.
Purpose: Ensures data integrity by controlling access to class attributes and enforcing program logic.

Bad Example: No Encapsulation

Class: BadBankAccount
Issue: Direct access to balance attribute allows invalid modifications (e.g., setting negative balance).
Code:class BadBankAccount:
    def __init__(self, balance):
        self.balance = balance

account = BadBankAccount(0.0)
account.balance = -1  # Allows negative balance
print(account.balance)  # Outputs: -1


Problem: No validation; clients can set balance to any value, violating program logic.

Improved Example: Partial Encapsulation

Class: BankAccount
Features:
balance initialized to 0.0.
Methods deposit and withdraw validate inputs:
deposit: Ensures amount > 0, else raises ValueError.
withdraw: Ensures amount > 0 and sufficient funds, else raises ValueError.




Code:class BankAccount:
    def __init__(self):
        self.balance = 0.0

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self.balance += amount

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdraw amount must be positive")
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        self.balance -= amount


Problem: balance can still be modified directly (e.g., account.balance = -1).

Best Example: Full Encapsulation

Class: BankAccount2
Features:
Uses protected attribute _balance (single underscore convention in Python to indicate internal use).
Provides @property getter for balance to allow controlled read access.
Omits setter to prevent direct modification of _balance.
deposit and withdraw methods enforce validation.


Code:class BankAccount2:
    def __init__(self):
        self._balance = 0.0

    @property
    def balance(self):
        return self._balance

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self._balance += amount

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdraw amount must be positive")
        if amount > self._balance:
            raise ValueError("Insufficient funds")
        self._balance -= amount

account = BankAccount2()
print(account.balance)  # 0.0
account.deposit(1.99)
print(account.balance)  # 1.99
account.withdraw(1)
print(account.balance)  # 0.99
# account.balance = -1  # ERROR: Cannot set balance directly


Benefits:
Protects _balance from direct modification.
Public API (deposit, withdraw) ensures safe operations and enforces business rules.
Getter property provides read-only access to _balance.



Key Points

Encapsulation hides internal data (_balance) and exposes a controlled interface (deposit, withdraw, balance property).
Pythonâ€™s _ prefix signals protected attributes, discouraging external access.
Properties (e.g., @property) provide a clean way to access attributes without verbose getter methods.
Ensures data integrity and program logic by preventing invalid operations (e.g., negative balance).
