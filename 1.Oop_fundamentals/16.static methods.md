Here’s a **clear summary** of the concepts covered in your transcript regarding **static vs. instance methods** in Python, using the `BankAccount` example:

---

## 🔁 **Instance Methods vs Static Methods in Python**

---

### ✅ **Instance Methods**

* Defined **with `self`** as the first parameter.
* Tied to a specific **instance (object)**.
* Can **access and modify instance attributes** like `self._balance`.

#### ✅ Use Case:

To perform actions that depend on or modify object-specific data.

#### ✅ Example:

```python
class BankAccount:
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
```

Here, `deposit()` modifies the `_balance` for **that specific account**.

---

### 🟩 **Static Methods**

* Defined **with `@staticmethod`** decorator.
* Do **not** take `self` as a parameter.
* Cannot access instance (`self`) or class (`cls`) data directly.
* Belong to the **class** itself, not individual instances.

#### ✅ Use Case:

When a method does **not rely on instance or class-specific data**, but is **logically related to the class**.

#### ✅ Example:

```python
@staticmethod
def is_valid_interest_rate(rate):
    return 0 <= rate <= 5
```

This method just checks the range of a number — no instance needed.

---

### 🔍 Summary Table

| Feature               | Instance Method            | Static Method                      |
| --------------------- | -------------------------- | ---------------------------------- |
| Takes `self`?         | ✅ Yes                      | ❌ No                               |
| Tied to object?       | ✅ Yes                      | ❌ No                               |
| Access instance data? | ✅ Yes (`self.attribute`)   | ❌ Not directly                     |
| Access class data?    | ✅ (via class or cls)       | ❌ Not directly                     |
| Declared with?        | No decorator               | `@staticmethod`                    |
| Typical use case      | Actions that modify object | Utility functions related to class |

---

### 🏦 Example Recap (Fixed and Cleaned)

```python
class BankAccount:
    MIN_BALANCE = 100  # Static (class-level) attribute

    def __init__(self, owner, balance=0):
        self.owner = owner
        self._balance = balance

    def deposit(self, amount):  # Instance method
        if amount > 0:
            self._balance += amount
            print(f"{self.owner}'s new balance: ${self._balance}")
        else:
            print("Deposit amount must be positive.")

    @staticmethod
    def is_valid_interest_rate(rate):  # Static method
        return 0 <= rate <= 5
```

### ✅ Usage:

```python
account = BankAccount("Alice", 500)
account.deposit(200)  # Instance method

print(BankAccount.is_valid_interest_rate(3))   # ✅ True
print(BankAccount.is_valid_interest_rate(10))  # ❌ False
```

---

### 🧠 Final Takeaways:

* Use **instance methods** when behavior needs to interact with the object’s state (`self`).
* Use **static methods** for general-purpose behavior that's **related to the class**, but **not dependent on any object**.
* Static methods = organizational tool → keeps helper logic inside relevant class without requiring object context.
* Both method types are stored once in **class memory**, leading to **efficient reuse** across instances.

---

Let me know if you want this broken into flashcards or turned into a cheat sheet.
