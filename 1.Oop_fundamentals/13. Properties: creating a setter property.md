Great! You're now working with the full power of Python's **`@property` system**—both getter and setter—to manage access to sensitive or controlled attributes like `email`.

---

### ✅ Cleaned-up and Correct Version of Your Code

```python
from datetime import datetime

class User:
    def __init__(self, username, email, password):
        self.username = username
        self._email = email  # Protected by convention
        self.password = password

    @property
    def email(self):
        print(f"Email accessed at {datetime.now()}")
        return self._email

    @email.setter
    def email(self, new_email):
        if "@" in new_email:
            self._email = new_email
        else:
            print("Invalid email address: must contain '@'")

# Creating a user
user1 = User("dantheman", "dan@gmail.com", "123")

# Try setting an invalid email
user1.email = "this is not an email"  # This will trigger validation and NOT set
print(user1.email)  # Still prints the original valid email

# Try setting a valid email
user1.email = "danny@outlook.com"
print(user1.email)
```

---

### 🧠 Summary: Python `@property` with Getter & Setter

#### ✅ Why use `@property`?

* It **looks like normal attribute access** (`user.email`) but secretly runs logic under the hood.
* Keeps external code **unchanged** even if internal logic changes.
* Makes code **clean, readable, and maintainable**.

#### 🛡 What we did:

* `self._email`: a *protected* attribute that holds the actual value.
* `@property`: defines a **getter** — runs when you do `user.email`.
* `@<property>.setter`: defines a **setter** — runs when you do `user.email = ...`.

#### 🔍 When the setter is triggered:

```python
user1.email = "some_value"
```

* Python calls the `email(self, new_email)` method under the hood.
* We added **validation logic** (e.g., email must contain `@`) here.
* If the new email is valid, we update `_email`; otherwise, we reject it.

---

### 🚀 Why this is powerful:

* You **don’t need to remember to validate manually** every time you set `email`.
* You **centralize logic in one place**.
* You **future-proof** your class—any added logic (e.g., logging, authorization, formatting) can go into the getter/setter **without changing other parts of your code**.

---
